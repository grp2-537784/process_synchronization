#define N 10
#define MUTEX 0
#define SEM 1
#define PERMISSION 100
#define READERS 100
#define WRITERS 10

int *buffer;

void down(int semId, int semNr, int val)

{

    struct sembuf op = {semNr, val<0?val:-val, 0};

    semop(semId, &op, 1);

}

void up(int semId, int semNr, int val)

{

    struct sembuf op = {semNr, val>0?val:-val, 0};

    semop(semId, &op, 1);

}

void writer(int id, int semId)

{

    int i;

    down(semId, SEM, PERMISSION); 

    printf("writer: %d\n", id);

    for (i=0; i<=N; i++) {

      buffer[i] = id * N + i;

      usleep(100000);

    }

    up(semId, SEM, PERMISSION);

}

void reader(int id, int semId)

{

    int localBuf[N], i;

    down(semId, SEM, 1);     

    printf("reader: %d - GET\n", id);

    for (i=0; i<=N; i++) {

     localBuf[i] = buffer[i];

     usleep(100000);

    }

    up(semId, SEM, 1);       

    // writing by mutual exclusion

    down(semId, MUTEX, 1);      // lock

    printf("reader: %d - PRINT\n", id);

    for (i=0; i<=N; i++)

        printf("%d ", localBuf[i]);

    printf("\n");

    up(semId, MUTEX, 1);        // release lock

}

int main(int argc, char **argv)

{

    int semId, shmId, i, pid, msg;

    shmId = shmget(IPC_PRIVATE, N * sizeof(int),IPC_CREAT | 0600);

    if (shmId < 0)

  {perror("error creating shared memory variable"); exit(2); }

 

    buffer = (int*) shmat(shmId, 0, 0);

 

    semId = semget(IPC_PRIVATE, 2, IPC_CREAT | 0600);

    if (semId < 0)

{ perror("Error creating semaphore"); exit(2); }

    // initialize semaphore

    semctl(semId, MUTEX, SETVAL, 1);

    semctl(semId, SEM, SETVAL, PERMISSION);    

    // create process for READERS and WRITERS

    if ((pid = fork()) == 0){ // free child process  WRITERS

        for (i=0; i<WRITERS; i++) {

            if (fork() == 0) {

                writer(i, semId);

                exit(0);

            }

            if ((i % (WRITERS/3)) == 0)

                sleep(3);

        }

        for (i=0; i<WRITERS; i++)

            wait(0);

    }

    else {  // free parent  WRITERS process

        for (i=0; i<READERS; i++) {

            if (fork() == 0) {

                reader(i, semId);

                exit(0);

            }

            if ((i % (READERS/5)) == 0)

                sleep(3);

        }

        for (i=0; i<READERS; i++)

            wait(0);

        waitpid(pid, 0);

        shmctl(shmId, IPC_RMID, 0);

        semctl(semId, IPC_RMID, 0);

    }

}
